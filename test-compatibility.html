<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Furlg æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .success { color: #28a745; }
        .warning { color: #ffc107; }
        .error { color: #dc3545; }
        .info { color: #17a2b8; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .result {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>ğŸ” Furlg æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•</h1>
    
    <div class="test-section">
        <h2>ğŸ“Š æµè§ˆå™¨ä¿¡æ¯æ£€æµ‹</h2>
        <button onclick="detectBrowser()">æ£€æµ‹æµè§ˆå™¨</button>
        <div id="browser-info" class="result"></div>
    </div>

    <div class="test-section">
        <h2>ğŸ”– ä¹¦ç­¾APIæµ‹è¯•</h2>
        <button onclick="testBookmarkAPI()">æµ‹è¯•ä¹¦ç­¾API</button>
        <button onclick="testPermissions()">æ£€æŸ¥æƒé™</button>
        <button onclick="requestPermissions()">è¯·æ±‚æƒé™</button>
        <div id="bookmark-test" class="result"></div>
    </div>

    <div class="test-section">
        <h2>ğŸ“š è·å–ä¹¦ç­¾æ•°æ®</h2>
        <button onclick="getBookmarks()">è·å–ä¹¦ç­¾</button>
        <div id="bookmark-data" class="result"></div>
    </div>

    <div class="test-section">
        <h2>ğŸ§ª å®Œæ•´å…¼å®¹æ€§æŠ¥å‘Š</h2>
        <button onclick="generateReport()">ç”ŸæˆæŠ¥å‘Š</button>
        <div id="compatibility-report" class="result"></div>
    </div>

    <script>
        // æµè§ˆå™¨æ£€æµ‹
        function detectBrowser() {
            const userAgent = navigator.userAgent;
            let browserInfo = {
                userAgent: userAgent,
                name: 'Unknown',
                version: '',
                isChrome: false,
                isEdge: false,
                isFirefox: false,
                isSafari: false
            };

            // æ£€æµ‹Edge
            if (userAgent.includes('Edg/')) {
                browserInfo.name = 'Microsoft Edge';
                browserInfo.isEdge = true;
                const match = userAgent.match(/Edg\/([0-9.]+)/);
                browserInfo.version = match ? match[1] : '';
            }
            // æ£€æµ‹Chrome
            else if (userAgent.includes('Chrome/') && !userAgent.includes('Edg/')) {
                browserInfo.name = 'Google Chrome';
                browserInfo.isChrome = true;
                const match = userAgent.match(/Chrome\/([0-9.]+)/);
                browserInfo.version = match ? match[1] : '';
            }
            // æ£€æµ‹Firefox
            else if (userAgent.includes('Firefox/')) {
                browserInfo.name = 'Mozilla Firefox';
                browserInfo.isFirefox = true;
                const match = userAgent.match(/Firefox\/([0-9.]+)/);
                browserInfo.version = match ? match[1] : '';
            }
            // æ£€æµ‹Safari
            else if (userAgent.includes('Safari/') && !userAgent.includes('Chrome/')) {
                browserInfo.name = 'Safari';
                browserInfo.isSafari = true;
                const match = userAgent.match(/Version\/([0-9.]+)/);
                browserInfo.version = match ? match[1] : '';
            }

            document.getElementById('browser-info').innerHTML = 
                `æµè§ˆå™¨åç§°: ${browserInfo.name}\n` +
                `ç‰ˆæœ¬: ${browserInfo.version}\n` +
                `User Agent: ${browserInfo.userAgent}\n` +
                `æ˜¯å¦Chrome: ${browserInfo.isChrome}\n` +
                `æ˜¯å¦Edge: ${browserInfo.isEdge}\n` +
                `æ˜¯å¦Firefox: ${browserInfo.isFirefox}\n` +
                `æ˜¯å¦Safari: ${browserInfo.isSafari}`;
        }

        // æµ‹è¯•ä¹¦ç­¾API
        function testBookmarkAPI() {
            let result = 'ä¹¦ç­¾APIæµ‹è¯•ç»“æœ:\n\n';
            
            // æ£€æŸ¥Chrome API
            if (typeof chrome !== 'undefined') {
                result += 'âœ… Chromeå¯¹è±¡å­˜åœ¨\n';
                if (chrome.bookmarks) {
                    result += 'âœ… chrome.bookmarks APIå¯ç”¨\n';
                } else {
                    result += 'âŒ chrome.bookmarks APIä¸å¯ç”¨\n';
                }
            } else {
                result += 'âŒ Chromeå¯¹è±¡ä¸å­˜åœ¨\n';
            }

            // æ£€æŸ¥WebExtension API
            if (typeof browser !== 'undefined') {
                result += 'âœ… Browserå¯¹è±¡å­˜åœ¨\n';
                if (browser.bookmarks) {
                    result += 'âœ… browser.bookmarks APIå¯ç”¨\n';
                } else {
                    result += 'âŒ browser.bookmarks APIä¸å¯ç”¨\n';
                }
            } else {
                result += 'âŒ Browserå¯¹è±¡ä¸å­˜åœ¨\n';
            }

            // æ£€æŸ¥å…¨å±€chrome
            if (typeof window !== 'undefined' && window.chrome && window.chrome.bookmarks) {
                result += 'âœ… å…¨å±€chrome.bookmarkså¯ç”¨\n';
            } else {
                result += 'âŒ å…¨å±€chrome.bookmarksä¸å¯ç”¨\n';
            }

            document.getElementById('bookmark-test').innerHTML = result;
        }

        // æ£€æŸ¥æƒé™
        async function testPermissions() {
            let result = 'æƒé™æ£€æŸ¥ç»“æœ:\n\n';
            
            try {
                if (chrome && chrome.permissions) {
                    result += 'âœ… chrome.permissions APIå¯ç”¨\n';
                    
                    const hasPermission = await new Promise((resolve) => {
                        chrome.permissions.contains({
                            permissions: ['bookmarks']
                        }, resolve);
                    });
                    
                    result += `ä¹¦ç­¾æƒé™çŠ¶æ€: ${hasPermission ? 'âœ… å·²æˆæƒ' : 'âŒ æœªæˆæƒ'}\n`;
                } else {
                    result += 'âŒ chrome.permissions APIä¸å¯ç”¨\n';
                }
            } catch (error) {
                result += `âŒ æƒé™æ£€æŸ¥å¤±è´¥: ${error.message}\n`;
            }

            document.getElementById('bookmark-test').innerHTML = result;
        }

        // è¯·æ±‚æƒé™
        async function requestPermissions() {
            let result = 'æƒé™è¯·æ±‚ç»“æœ:\n\n';
            
            try {
                if (chrome && chrome.permissions) {
                    const granted = await new Promise((resolve) => {
                        chrome.permissions.request({
                            permissions: ['bookmarks']
                        }, resolve);
                    });
                    
                    result += `æƒé™è¯·æ±‚ç»“æœ: ${granted ? 'âœ… å·²æˆæƒ' : 'âŒ è¢«æ‹’ç»'}\n`;
                } else {
                    result += 'âŒ chrome.permissions APIä¸å¯ç”¨ï¼Œæ— æ³•è¯·æ±‚æƒé™\n';
                }
            } catch (error) {
                result += `âŒ æƒé™è¯·æ±‚å¤±è´¥: ${error.message}\n`;
            }

            document.getElementById('bookmark-test').innerHTML = result;
        }

        // è·å–ä¹¦ç­¾
        async function getBookmarks() {
            let result = 'ä¹¦ç­¾è·å–ç»“æœ:\n\n';
            
            try {
                let bookmarkTree = null;
                
                if (chrome && chrome.bookmarks) {
                    result += 'ä½¿ç”¨chrome.bookmarks API\n';
                    bookmarkTree = await new Promise((resolve, reject) => {
                        chrome.bookmarks.getTree((tree) => {
                            if (chrome.runtime.lastError) {
                                reject(new Error(chrome.runtime.lastError.message));
                            } else {
                                resolve(tree);
                            }
                        });
                    });
                } else if (browser && browser.bookmarks) {
                    result += 'ä½¿ç”¨browser.bookmarks API\n';
                    bookmarkTree = await browser.bookmarks.getTree();
                } else {
                    throw new Error('æ²¡æœ‰å¯ç”¨çš„ä¹¦ç­¾API');
                }

                // æå–ä¹¦ç­¾
                const bookmarks = [];
                function extractBookmarks(nodes) {
                    nodes.forEach(node => {
                        if (node.url && node.title) {
                            if (node.url.startsWith('http://') || node.url.startsWith('https://')) {
                                bookmarks.push({
                                    title: node.title,
                                    url: node.url
                                });
                            }
                        }
                        if (node.children) {
                            extractBookmarks(node.children);
                        }
                    });
                }

                extractBookmarks(bookmarkTree);
                
                result += `âœ… æˆåŠŸè·å– ${bookmarks.length} ä¸ªä¹¦ç­¾\n\n`;
                result += 'å‰10ä¸ªä¹¦ç­¾:\n';
                bookmarks.slice(0, 10).forEach((bookmark, index) => {
                    result += `${index + 1}. ${bookmark.title}\n   ${bookmark.url}\n\n`;
                });

            } catch (error) {
                result += `âŒ è·å–ä¹¦ç­¾å¤±è´¥: ${error.message}\n`;
            }

            document.getElementById('bookmark-data').innerHTML = result;
        }

        // ç”Ÿæˆå®Œæ•´æŠ¥å‘Š
        function generateReport() {
            detectBrowser();
            testBookmarkAPI();
            
            setTimeout(() => {
                const browserInfo = document.getElementById('browser-info').innerHTML;
                const bookmarkTest = document.getElementById('bookmark-test').innerHTML;
                
                const report = 
                    '=== Furlg æµè§ˆå™¨å…¼å®¹æ€§æŠ¥å‘Š ===\n\n' +
                    'æµè§ˆå™¨ä¿¡æ¯:\n' + browserInfo + '\n\n' +
                    'ä¹¦ç­¾APIæµ‹è¯•:\n' + bookmarkTest + '\n\n' +
                    'å»ºè®®:\n';
                
                let recommendations = '';
                if (browserInfo.includes('Microsoft Edge')) {
                    if (bookmarkTest.includes('chrome.bookmarks APIå¯ç”¨')) {
                        recommendations += 'âœ… Edgeæµè§ˆå™¨å®Œå…¨æ”¯æŒï¼Œå¯ä»¥ä½¿ç”¨ç›´æ¥å¯¼å…¥åŠŸèƒ½\n';
                    } else {
                        recommendations += 'âš ï¸ Edgeæµè§ˆå™¨APIå—é™ï¼Œå»ºè®®ä½¿ç”¨æ–‡ä»¶å¯¼å…¥æ–¹å¼\n';
                        recommendations += '   å¯¼å‡ºæ–¹å¼: è®¾ç½® â†’ æ”¶è—å¤¹ â†’ å¯¼å‡ºæ”¶è—å¤¹\n';
                    }
                } else if (browserInfo.includes('Google Chrome')) {
                    recommendations += 'âœ… Chromeæµè§ˆå™¨å®Œå…¨æ”¯æŒ\n';
                } else if (browserInfo.includes('Mozilla Firefox')) {
                    recommendations += 'âš ï¸ Firefoxå¯èƒ½éœ€è¦ä½¿ç”¨WebExtension API\n';
                } else {
                    recommendations += 'âŒ æœªçŸ¥æµè§ˆå™¨ï¼Œå»ºè®®ä½¿ç”¨æ–‡ä»¶å¯¼å…¥æ–¹å¼\n';
                }

                document.getElementById('compatibility-report').innerHTML = report + recommendations;
            }, 100);
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ£€æµ‹
        window.onload = function() {
            detectBrowser();
        };
    </script>
</body>
</html>
